# Лабораторная работа №3
## Цель работы
Сделать, чтобы после пуша в ваш автоматически собирался докер образ и результат его сборки сохранялся. В нашем случае будем сохранять его на **dockerhub**.

## Начало работы
Для выполнения данной лабораторной работы был написан пройстейший docker файл, который запускает python программу.

### Docker файл
![docker](./img/docker.jpg)

### Файл с библиотеками
![rec](./img/requirements.jpg)
### Код python программы
![code](./img/code.jpg)

## Основная часть

Далее создадим [репозиторий на github](https://github.com/MartinAbdrakhmanov/cloudslab3) и создадим файл **docker-image.yml**, содержащий инструкции для **github actions**.
![yml](./img/yml.png)

### Описание инструкии
1. Поле *name* задает имя.
2. Поле *on* задает условия срабатывания. В нашем случае это пуш или пулреквест в *main* ветку.
3. Поле *jobs* задает параметры при срабатывании. В нем имеем:
   1. *name* - название операции.
   2. *runs-on* - образ на основе которого будет выполняться конфигурация
   3. *steps* - шаги выполнения. Имеем соответствующие шаги с проверкой репозитория, входом в dockerhub и сборка образа с последующим пушем.

Запушем с помощью **github actions** файл в репозиторий в **dockerhub**.
![pushyml](./img/pushyml.png)

Заметим, что файл успешно запушился в **dockerhub**
![dockerhub](./img/dockerhub.png)

Запустим контейнер и увидим, что контейнер был успешно запушен
![startcont](./img/startcont.png)

### Автоматическое обновление после изменений
Немного изменим код в python-файле и запушим его на **github**. (Изменения видны на скриншоте)
![changecode](./img/changecode.png)

Заметим, что **github actions** автоматически запушили изменения на **dockerhub**.
![autopush](./img/autopush.png)

И наблюдаем за успешно успешно запущенным ***измененным*** докером.
![newcont](./img/newcont.png)

## Вывод
В ходе данной лабораторной работы была реализована возможность автоматической сборки докер образа, а его результат его сборки сохранялся на **dockerhub**


